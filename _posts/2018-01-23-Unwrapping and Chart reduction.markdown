---
layout:     post
title:      "Unwrapping and Chart reduction"
subtitle:   " \"UV展开和图表的减少\""
date:       2017-01-23 12:00:00
author:     "Wei"
header-img: "img/20180123/title_bg.jpg"
catalog: true
tags:
    - 翻译
---


## UV展开和图表的减少
我们在灯光的预计算中适当的排除了一些对象，在减少了数量的图表后，我们开始做一些下列工作。

创建的图表是用来包含静态网格渲染器的UV光照贴图坐标。因此，一个对象所请求的图表的数量很大程度上取决于需要展开对象UV外壳的数量。展开是一个在几何面上分布的像素失真度和足够的图形覆盖需要的外壳的数量权衡。

Unity 复杂的解压算法能得到一个好的结果而不用我们的操作。然而，有时候我们还是需要提供一些引导调整。因此我们有必要了解自动展开UV的理论和过程。

观察下面的图片：

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction1.png" />
<small class="img-hint">不失真的UV展开，但是需要多张UV外壳</small>

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction2.png" />
<small class="img-hint">用单一的UV外壳形成的UV坐标，但是失真严重</small>

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction3.png" />
<small class="img-hint">一个真实的没有贴图失真的单一的UV外壳的结果</small>

以上图片，我们展示了3个不同的例子关于UV的投射和展开。

在第一张图片上，我们看到没有失真的结果。我们使用检查器模式作为一个图片映射的方式，以致纹理的瓦片在各方面保持正方形。试想如果这个棋盘是一个光照贴图（一个作用到对象上的灯光图片），我们可以得到视觉上看起来正确没有失真的效果。然而，我们需要6个UV外壳去得到这样的覆盖。结果是，我们使用Unity预计算的实时GI系统是将得到6个图表。不管对象的大小是多少，每个图片需要最小4x4个像素，这意味着不管多少分辨率每个对象至少需要96个像素。

在第二张图片上，我们有不同的问题。对象的UV图片坐标已经被投射下以致于我们可以得到完整的覆盖整个面的UV外壳。它在需要覆盖对象的图表的数量的方面上是理想的，但是视觉上的结果是不令人接受的。我们通过对象的表面可能看到图片的污点的产生。对象的表面在UV图片的空间也有重复，这意味着如果我们把它作为一个光照贴图，物体另一侧的灯光将会被显示在相反的表面。明显的这样的对象展开的方法不会给我们一个可接受的结果。

第三张图展示了一个理想的展开例子。我们得到一个不失真的结果，我们棋盘的瓦片贴图上在各方面保持正方形。我们也成功的覆盖对象各个方面，仅仅输出了一个UV外壳。这是通过连接或者缝合在模型上连续的几何边缘对应的UV的边缘来实现的。

如果我们以编程的方式思考这个，我们如何实现这个理想的展开？第一步，我们通过UV投影正交地投到对象上创建我们的单独的外壳。然后我们分析这些在相应的几何对象上共享的外壳的边缘。当这些共享的边缘被找到，我们移动并且缝合这些外壳到他们相邻的上。这就是Unity 对于静态的几何物体自动的展开算法。

### 可视化的图表

在我们优化我们展开的光照贴图图表之前，我们需要在编辑器下可视化他们。图表被生成在网格导入管道展开的阶段。对于预计算的实时GI，这些图表被打包在图集里在几何预计算的过程的阶段。这样确保他们不会有重复的部分。我们可以仅仅看到一次我们图表的预览在几何预计算被完成的阶段并且可视化的数据被存储起来。

如果你在版本控制的团队中工作，需要知道本地缓存的信息。这意味着在各种诊断的绘画的模式是否是可用之前必须在本地的机器上进行预计算。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction4.png" />
<small class="img-hint">UV图表绘制模式,表示了在场景中通过颜色区域使用和光照贴图的分辨率通过棋牌覆盖代表不同的图表</small>

一个快速的可视化你的图表通过使用UV Charts draw 模式在场景视图中。

    --在场景视图的左上角，使用Darw Moded 下拉菜单选择UV Charts。

使用这个模式，图表可以被视为不同颜色的面板，上面覆盖的棋盘格子代表着光照贴图分辨率。如果你打开自动的模式（WIndow>Lighting>Auto），改变展开的参数将会被自动评估并且场景视图的结果将会被更新。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction5.png" />
<small class="img-hint">对象预览窗口的图表模式，用彩色正方形表示的光照图表，用浅蓝色线框表示的光照贴图UV</small>

当复杂的对象工作的时候是很容易的遗漏场景中的一些图表。通过使用Lighting窗口的面板，我们可以通过单独的对象观察它的所有图表的使用。它可以帮助我们更精确地评估这些展开的对象，它可以帮助我们减少我们场景中图表的数量。

    --打开Lighting 窗口（Windows>Lighting） 并且选择Object 标签
    --从层级窗口选择我们需要查看的对象
    --在Lighting窗口的预览面板的左上角，在下拉菜单中选择Charting。

对象使用图表的数量通过覆盖的浅蓝色的相应的UV坐标的彩色正方形表示。



### 展开参数解释

这里有一些设置我们可以调整去优化UV展开。所有的设置都是对单独的对象的。我们可以使用这些设置通过Lighting窗口。如下：

    --打开Lighting窗口（Windows>Lighting）并且选择Object标签
    --从层级窗口选择我们需要查看的对象

#### 自动最大距离UV

Unity 的展开算法尝试去采集光照贴图的UV通过移动外壳并且一起缝合UV边缘。UV外壳被考虑进优化内如果外壳都被包含在定义了自动最大距离UV范围内。这个范围被定义在Unity的世界空间单元。在我们的教程场景我们假定每个单元为1m。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction6.png" />
<small class="img-hint">自动最大距离UV可以在Lighting窗口的Object标签下被找到</small>

在大多数情况下默认定义的0.5单元将会给出一个可接受的结果。对于一些特殊的巨大表面的物体，它需要增加这个值。 它是防止合适的候补的UV被拼接算法排除在外。

增加自动最大距离UV将会减少图表的数量。在这样的场景下减少这个值是很有用的，有可见的光照贴图像素展开和我们可能实际上需要更多的图表为了得到请求像素的覆盖范围。这些改变的结果是很容易被评估在使用棋盘覆盖的UV图表场景绘画模式。找到一个正确的平衡点需要一些小小的试验。

#### 自动最大角度UV

光照UV外壳也会被评估为了拼接基于角度的在相邻的相应的表面网格之间。自动最大角度UV被定义为最大的允许的角度在分享的UV边缘和被计算使用的这个强度角度的表面之间。如何在背面之间的角度比这个数值大，则这个UV外壳将不会被拼接进来。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction7.png" />
<small class="img-hint">自动最大角度UV可以在Lighting窗口的Object标签下被找到</small>

增大这个值将会可能使光照贴图的UV被合并通过Unity的展开算法，自动最大角度UV因此是一个很好的办法去减少被选择对象需要的图表的数量。然而，有时候光照贴图可能发生拉伸当这个太过松懈这个值。减小自动最大角度UV将会使展开不太可能合并UV边缘，它的结果是更多的图表但是不失真。再一步说，使用棋盘覆盖场景UV图表绘制模式是一个很好的方法去尝试一个最合适的值。

#### 保持UV

 有一些情况下，使用自动展开方式不可能得到理想的展开。我们最后可能得到大量的图表或者不可接受的失真的光照贴图（在GI图表绘画模式下可以直观地看到拉伸的棋盘）。在这些情况下就需要手动地去制作UVs在我们模型文件的UV01通道。这是我们在选择内容创建包的时候需要做的工作。

如果是在这种情况下，我们需要使用Preserve UVs 选项来强迫Unity展开算法保持UV外壳的形状是被定义在你的模型的UV01 通道。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction8.png" />
<small class="img-hint">Preserve UVs 选项是十分有用的，当需要手动保留的灯光UVs </small>

它是很重要的去注意到，这些外壳将会被重新打包去保存在光照贴图的空间中。这是一个外壳被单独的展开的方式，保持UV而不是光照贴图中外壳的位置。

我们必须非常小心在使用这种方式的时候，在这种方式下我们的光照贴图UVs包含大量的UV外壳，这个选项将会增加预计算的时间。这是因为Unity自动展开提供的UV合并步骤被绕过并且我们手动的UV布局被保持。记住尽可能的使用更少的UV外壳或更少的图表得到想要的结果，将其保持可接受的失真等级下。

#### 忽略法线

在某些情况下，网格导入器可能决定分割几何。它也会影响图表。举个例子，如果一个网格有很高的三角数量，它可能会消耗更多的性能，Unity 会去分割它成为子网格。常常这么做它是为了硬件的需求，比如减少每个draw call三角形的数量。在什么地方发生的分割决定于在临近的网格表面有巨大的法线角度变化的区域，比如硬边缘。分割模型在你的模型网格导入过程中发生。图表可能在这个过程中被分割，因为图表的边缘可能被分割，结果是有复制外壳生成转而请求额外的图表。

<img class="shadow" src="/img/20180123/Unwrapping_and_Chart_reduction9.png" />
<small class="img-hint"> 在导入管道期间忽略法线的复选框将阻止图表的拆分 </small>

有时候这种分割图表的方式是不可取的。结果是增加了图表的数量是有害的对于预计算的时间，并且灯光的缝合处会造成不想要的视觉上的人工制品在产生的光照贴图上。另一方面，打开Ignore Normals 复选框将会阻止图表因为预计算的实时GI灯光造成的分割。

注意到这个选项只有对预计算的实时GI才有影响。物件被拆分的网格仍然会被保留用于其他用途。

### 更快速迭代大场景

复杂的场景可能包含几百个甚至几千个静态的物体，为这些对象生成图表的地图册可能会导致在缓慢的灯光预计算并且可能对于我们在场景中的迭代速度产生负面的影响。

当尝试着为这些对象展开设置，有时候它可能是有用的去隔离一个在空场景中感兴趣的对象，场景中我们可以快速的迭代通过很少的预计算的时间。我们确立的展开设置可以被拿来并且应用到我们最初的场景中的同类型的其他对象上。通过这样的方法可以有很好的时间的提示当准备场景中的灯光的时候。

    --打开例子工程中的LightingTutorialStart 场景。
    --在层级窗口中选择其中一个名叫HouseBig02 的对象。这些租在Environment>Structures>Huoses.
    --复制这个对象在剪切板上通过按下Ctrl + C（Mac 上是Cmd +C）
    --创建一个新的场景通过按下Ctrl + N（Mac 上是Cmd +N）
    --如果提示你保持你的改变，选择Yes 保存场景或者No如果不喜欢抛弃他。
    --在新的场景的场景中，从剪切板上粘贴HouseBig02 通过Ctrl + V（Mac 上是Cmd +V）
    --打开Lighting 窗口（Windows>Lighting）并且选择Scene 标签。
    --打开自动预计算模式通过打开Auto复选框。
    --选择Object标签。
    --在左上角的Object标签上，从下拉菜单中选择Charting。
    --放大预览的区域观察对象是怎么被展开的。

### 后记
自己学习翻译，本翻译仅供学习。
[原文](https://unity3d.com/cn/learn/tutorials/topics/graphics/unwrapping-and-chart-reduction?playlist=17102)